# Сеть Фейстеля для пятилетних и не только

## Что такое шифрование простыми словами

Представь, что у тебя есть секрет, и ты хочешь рассказать его другу, но боишься, что кто-то подслушает. Можно придумать особый язык, который знаете только вы двое!

Шифрование — это как волшебное превращение твоего секрета в непонятные каракули. Потом твой друг, зная волшебное слово (ключ), может превратить каракули обратно в секрет.

## Что такое сеть Фейстеля

Сеть Фейстеля — это как особая игра в "испорченный телефон", но с правилами:

1. Разделим наш секрет на две половинки: левую и правую.
2. Правую половинку перемешаем по особым правилам с волшебным словом.
3. Результат смешаем с левой половинкой.
4. Поменяем половинки местами.
5. Повторим эти шаги много раз!

Самое интересное, что чтобы расшифровать секрет, нужно сделать те же шаги, только в обратном порядке и с теми же волшебными словами!

## Разбор кода

### Генерация ключа

```python
def generate_key(bits=64):
    return random.getrandbits(bits)
```

Это как бросить монетку 64 раза и записать, когда выпадает орёл, а когда решка. Получается очень длинное случайное число, которое будет нашим главным секретным ключом.

### Разделение блока на половинки

```python
def split_block(block):
    left = (block >> 32) & 0xFFFFFFFF
    right = block & 0xFFFFFFFF
    return left, right
```

Здесь блок (64-битное число) делится на две части:
- `block >> 32` сдвигает все биты вправо на 32 позиции, отбрасывая правую половину
- `& 0xFFFFFFFF` (побитовое И с 32 единицами в шестнадцатеричной системе) обеспечивает, что мы получаем ровно 32 бита
- Для правой половины просто применяем маску `& 0xFFFFFFFF`, чтобы взять только младшие 32 бита

Это как разрезать открытку пополам — получаем две половинки.

### Соединение половинок

```python
def combine_halves(left, right):
    return (left << 32) | right
```

Здесь мы делаем обратную операцию:
- `left << 32` сдвигает левую половину влево на 32 позиции, освобождая место для правой
- `|` (побитовое ИЛИ) вставляет правую половину в освобожденное место

Это как склеить две половинки открытки обратно.

### Функция Фейстеля

```python
def feistel_function(half_block, round_key):
    result = half_block ^ round_key
    result = ((result >> 8) | (result << 24)) & 0xFFFFFFFF
    result = ((result << 3) | (result >> 29)) & 0xFFFFFFFF
    result = result ^ ((round_key << 5) & 0xFFFFFFFF)
    return result
```

Это сердце шифрования! Здесь происходит "перемешивание":

1. `half_block ^ round_key` — XOR (исключающее ИЛИ) смешивает биты половинки с ключом. Это как сложить цифры, но без переноса (1+1=0).
2. `((result >> 8) | (result << 24)) & 0xFFFFFFFF` — делает циклический сдвиг вправо на 8 бит. Представь, что последние 8 символов переносятся в начало.
3. `((result << 3) | (result >> 29)) & 0xFFFFFFFF` — делает циклический сдвиг влево на 3 бита.
4. `result ^ ((round_key << 5) & 0xFFFFFFFF)` — еще раз смешиваем с ключом, но уже сдвинутым.

Это как если бы ты взял слово, поменял некоторые буквы, переставил начало в конец и снова поменял буквы.

### Генерация ключей для раундов

```python
def generate_round_keys(master_key, rounds=16):
    round_keys = []
    for i in range(rounds):
        shifted_key = ((master_key << i) | (master_key >> (64 - i))) & 0xFFFFFFFFFFFFFFFF
        round_key = shifted_key ^ (i * 0x0123456789ABCDEF)
        round_keys.append(round_key & 0xFFFFFFFF)
    return round_keys
```

Из одного главного ключа мы создаем 16 разных ключей (по одному для каждого раунда):

1. `((master_key << i) | (master_key >> (64 - i)))` — циклически сдвигаем главный ключ на `i` бит.
2. `shifted_key ^ (i * 0x0123456789ABCDEF)` — смешиваем результат с особым числом, умноженным на номер раунда.
3. `round_key & 0xFFFFFFFF` — берем только 32 бита, потому что функции Фейстеля нужно именно столько.

Это как сделать 16 разных "волшебных слов" из одного главного, чтобы каждый раунд был уникальным.

### Один раунд шифрования

```python
def feistel_round(left, right, round_key):
    f_result = feistel_function(right, round_key)
    new_left = right
    new_right = left ^ f_result
    return new_left, new_right
```

Здесь происходит основная магия сети Фейстеля:

1. Применяем функцию Фейстеля к правой половине с текущим ключом.
2. Новая левая половина становится старой правой.
3. Новая правая половина — это XOR между старой левой и результатом функции Фейстеля.
4. Возвращаем новые половинки (фактически они поменялись местами).

Это как если бы мы перемешали правую половину, смешали с левой, а потом поменяли половинки местами.

### Шифрование блока

```python
def encrypt_block(block, master_key, rounds=16):
    round_keys = generate_round_keys(master_key, rounds)
    left, right = split_block(block)
    for i in range(rounds):
        left, right = feistel_round(left, right, round_keys[i])
    return combine_halves(right, left)
```

Полное шифрование блока:

1. Генерируем все ключи для раундов.
2. Делим блок на две половины.
3. Выполняем 16 раундов шифрования.
4. В конце объединяем половинки, но с перестановкой (правая, левая).

Эта последняя перестановка — важный момент! Она упрощает расшифрование, так как обе половинки уже на своих местах для начала обратного процесса.

### Расшифрование блока

```python
def decrypt_block(block, master_key, rounds=16):
    round_keys = generate_round_keys(master_key, rounds)
    left, right = split_block(block)
    for i in range(rounds - 1, -1, -1):
        left, right = feistel_round(left, right, round_keys[i])
    return combine_halves(right, left)
```

Расшифрование почти идентично шифрованию, но с двумя отличиями:

1. Ключи применяются в обратном порядке (`range(rounds - 1, -1, -1)`).
2. В остальном процесс тот же — это красота сети Фейстеля!

### Преобразование текста в блоки

```python
def text_to_blocks(text, block_size=8):
    bytes_data = text.encode('utf-8')
    padding_size = block_size - (len(bytes_data) % block_size)
    if padding_size < block_size:
        bytes_data += bytes([padding_size]) * padding_size
    blocks = []
    for i in range(0, len(bytes_data), block_size):
        block = struct.unpack('>Q', bytes_data[i:i+block_size])[0]
        blocks.append(block)
    return blocks
```

Здесь текст превращается в блоки по 64 бита:

1. `text.encode('utf-8')` — превращаем текст в байты.
2. Вычисляем сколько байт нужно добавить, чтобы получить кратное 8 количество.
3. `bytes_data += bytes([padding_size]) * padding_size` — добавляем байты, все со значением равным размеру дополнения.
4. `struct.unpack('>Q', bytes_data[i:i+block_size])[0]` — превращаем 8 байт в одно 64-битное число. `>Q` означает "большой 64-битный целое число без знака".

Это как нарезать длинное сообщение на кусочки одинакового размера, а если последний кусок маленький — дополнить его.

### Преобразование блоков обратно в текст

```python
def blocks_to_text(blocks, block_size=8):
    bytes_data = b''
    for block in blocks:
        bytes_data += struct.pack('>Q', block)
    padding_size = bytes_data[-1]
    if padding_size < block_size:
        bytes_data = bytes_data[:-padding_size]
    return bytes_data.decode('utf-8')
```

Тут делаем обратное преобразование:

1. `struct.pack('>Q', block)` — превращаем каждое 64-битное число в 8 байт.
2. `padding_size = bytes_data[-1]` — последний байт говорит нам, сколько байт было добавлено.
3. `bytes_data = bytes_data[:-padding_size]` — удаляем добавленные байты.
4. `bytes_data.decode('utf-8')` — превращаем байты обратно в текст.

Это как склеить кусочки сообщения обратно и удалить лишние добавленные символы.

### Шифрование и расшифрование текста

```python
def encrypt_text(text, key):
    blocks = text_to_blocks(text)
    encrypted_blocks = []
    for block in blocks:
        encrypted_block = encrypt_block(block, key)
        encrypted_blocks.append(encrypted_block)
    return encrypted_blocks

def decrypt_text(encrypted_blocks, key):
    decrypted_blocks = []
    for block in encrypted_blocks:
        decrypted_block = decrypt_block(block, key)
        decrypted_blocks.append(decrypted_block)
    return blocks_to_text(decrypted_blocks)
```

Эти функции обрабатывают весь текст целиком:

1. Делим текст на блоки.
2. Шифруем/расшифровываем каждый блок отдельно.
3. Собираем результат.

## Особенности и сложные места

1. **Битовые операции**: Операции `&`, `|`, `^`, `<<`, `>>` используются для работы с отдельными битами. Это как играть с очень маленькими лего-кубиками.

2. **XOR (^)** — ключевая операция в криптографии, потому что:
   - Она обратима: A ^ B ^ B = A
   - Поэтому: шифрованный ^ ключ = исходный ^ ключ ^ ключ = исходный

3. **Дополнение (padding)**: Добавляем байты, чтобы сообщение имело длину, кратную 8. Последний байт указывает, сколько байт было добавлено.

4. **Циклические сдвиги**: Операции вроде `(x << n) | (x >> (32-n))` перемещают биты по кругу, а не просто влево или вправо.

5. **Сеть Фейстеля**: Главная идея в том, что каждый раунд меняет только половину данных и переставляет половинки. Это делает алгоритм расшифрования почти идентичным алгоритму шифрования.

Вот почему сеть Фейстеля — это гениально просто! Ты можешь зашифровать сообщение, а друг расшифровать его, используя почти одинаковый процесс, просто в обратном порядке.