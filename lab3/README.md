# ГОСТ 28147-89: Шифрование файлов на Python

## 1. Что такое ГОСТ 28147-89?

ГОСТ 28147-89 — это старый советский стандарт шифрования. Он берет текст, превращает его в секретный набор байтов и только с правильным ключом его можно снова прочитать.

### Простое объяснение:

Представь, что у тебя есть волшебный сундук. Ты можешь положить в него записку, закрыть его на замок (зашифровать), и никто не сможет её прочитать, кроме того, у кого есть правильный ключ (расшифрование).

---

## 2. Как работает этот код?

Этот код помогает зашифровать и расшифровать файлы с помощью ГОСТ 28147-89.

### Основные шаги:

1. **Создание ключа** – программа генерирует случайный ключ (32 байта).
2. **Шифрование файла** – берётся текст, разбивается на кусочки по 8 байтов, заменяются символы по специальным правилам (S-блоки), перемешиваются, и в итоге получается зашифрованный файл.
3. **Расшифрование файла** – программа делает всё наоборот: берёт зашифрованные байты, применяет обратные преобразования и получает исходный текст.

---

## 3. Разбор кода

### **1. Генерация ключа**

```python
key = os.urandom(32)
with open("key.bin", "wb") as f:
    f.write(key)
```

Код создаёт 32 случайных байта (ключ) и сохраняет их в файл `key.bin`. Этот ключ нужен для шифрования и расшифрования.

### **2. Шифрование блока**

```python
n1, n2 = struct.unpack('<II', block)
```

Здесь программа берёт 8 байтов текста и делит их на две части по 4 байта (n1 и n2).

```python
for i in range(32):
    k = key[i % 8]  # Берём один из 8 ключей
    s = (n1 + k) & 0xFFFFFFFF  # Складываем числа и берём только 4 байта
```

Программа 32 раза выполняет магические преобразования с числами. Это нужно, чтобы шифр был сложным и его нельзя было взломать простыми методами.

```python
return struct.pack('<II', n2, n1)  # Возвращаем зашифрованный блок
```

В конце программа записывает результат обратно в 8 байтов.

### **3. Шифрование файла**

```python
with open(input_path, "rb") as fin, open(output_path, "wb") as fout:
    while chunk := fin.read(8):  # Читаем файл по 8 байтов
        if len(chunk) < 8:
            chunk = pkcs7_pad(chunk)  # Добавляем паддинг, если не хватает байтов
        fout.write(gost_encrypt_block(chunk, key))  # Шифруем и записываем
```

Программа читает файл кусками по 8 байтов, шифрует их и сохраняет в новый файл.

### **4. Расшифрование файла**

```python
decrypted_data = b"".join(gost_decrypt_block(encrypted_data[i:i+8], key) for i in range(0, len(encrypted_data), 8))
```

Программа берёт зашифрованный файл, разбивает его на блоки по 8 байтов, расшифровывает каждый блок и соединяет обратно в текст.

```python
with open(output_path, "wb") as f:
    f.write(pkcs7_unpad(decrypted_data))
```

Здесь удаляется лишний паддинг (специальные добавочные байты) и записывается расшифрованный текст в файл.

---

## 4. Как использовать программу?

1. **Запустить файл** `python gost.py`
2. Выбрать **действие** в меню:
   - `1` — сгенерировать ключ
   - `2` — зашифровать файл
   - `3` — расшифровать файл
   - `4` — выйти
3. Следовать инструкциям и указывать файлы.

### Пример:

```bash
Введите имя файла для ключа (по умолчанию key.bin): key.bin
Ключ сохранен в key.bin
Файл для шифрования: input.txt
Файл для сохранения: encrypted.bin
Файл с ключом: key.bin
Файл зашифрован и сохранен как encrypted.bin
```

```bash
Файл для расшифрования: encrypted.bin
Файл для сохранения: decrypted.txt
Файл с ключом: key.bin
Файл расшифрован и сохранен как decrypted.txt
```

---

## 5. Заключение

Этот код позволяет легко зашифровывать и расшифровывать файлы с помощью ГОСТ 28147-89. Если потерять ключ, расшифровать файл уже не получится!
